# Звіт архітектурного ревʼю: контрольованість і перевіряльність

## 0) Короткий висновок

У поточному шаблоні **майже немає "сигналів" для перевірок** (у CI, IaC та деплойменті), тому система легко "мовчить" щодо:

-   витоків секретів (немає сигналу для gitleaks),
-   вразливостей у контейнері (немає SBOM для trivy),
-   небезпечних налаштувань Kubernetes/Terraform (немає сигналу для OPA/tfsec),
-   відсутності health/observability (немає сигналу для моніторингу),
-   порушення PoLP (немає сигналу для policy checker).

**Висновок:** архітектура не дозволяє автоматичну перевірку, тому інструменти безпеки "сліпі" - вони не бачать проблеми не через їх відсутність, а через відсутність **сигналів** для їх виявлення.

Нижче - 6 ключових дефектів архітектури, які демонструють **порушення контрольованості** та відсутність **сигналів для перевірок**, з практичними варіантами виправлення через **патерни / гейти / політики**.

---

## 1) Чекліст сигналів (на рівні архітектури)

| Сигнал / контроль                                           |      Статус | Де очікується |
| ----------------------------------------------------------- | ----------: | ------------- |
| SAST (semgrep/bandit)                                       |          ❌ | CI            |
| Secret scanning (gitleaks)                                  |          ❌ | CI            |
| Dependency / container scan (trivy/grype)                   |          ❌ | CI            |
| SBOM generation (syft)                                      |          ❌ | CI            |
| Image signing + verification (cosign + policy)              |          ❌ | CI + Cluster  |
| Policy-as-Code для K8s/IaC (OPA/Conftest, checkov/tfsec)    |          ❌ | CI            |
| Runtime security posture (securityContext, non-root, RO FS) |          ❌ | K8s manifests |
| Observability signals (health endpoint, structured logs)    | ❌/частково | App + K8s     |

---

## 2) Виявлені проблеми (формат: файл → проблема → принцип → чому "без сигналу" → фікси)

### Проблема 1 - Відсутня валідація/типізація і явні контракти API

**Файл:** `main.py`  
**Суть:** endpoints приймають довільні параметри без типів/схем; використання `Request` + `request.json()` (асинхронне, без валідації), немає `response_model`, немає контрольованих помилок/статус-кодів.  
**Порушений принцип/патерн:** _Fail-safe defaults_, **"Contract-first / Schema-driven validation"**, **контрольованість API**.  
**Чому система "мовчить" без сигналу:**

-   Без схем і типів немає формального **контракту** → CI не може робити API-check/contract-tests
-   SAST (semgrep) не ідентифікує `id` як user input, бо немає типізації → не може перевірити валідацію
-   DAST не знає, як формувати запити, бо немає OpenAPI-опису
-   **Архітектура не надає сигналу для автоматичної перевірки** - інструменти "сліпі"

**Виправлення (патерн "OpenAPI + типізовані моделі"):**

-   Ввести **Pydantic-моделі** для request/response (`BaseModel`), `response_model=...` - це створює **сигнал** (OpenAPI schema) для автоматичної перевірки
-   Додати **mypy/ruff** у CI як **гейт** (quality gate) - це додає **контроль** на рівні пайплайну
-   Обробляти помилки через `HTTPException`, повертати коректні коди
-   **Результат:** DAST може згенерувати запити, Semgrep бачить user input, contract testing працює

---

### Проблема 2 - Hardcoded secret / небезпечна логіка автентифікації

**Файл:** `main.py`  
**Суть:** пароль/секрет прямо у коді (`"secret"`), примітивна перевірка, без хешування, rate-limit, audit trail.  
**Порушений принцип/патерн:** **"Secret Management"**, _Zero Trust_, **_PoLP_** (секрет не має бути в коді).  
**Чому система "мовчить" без сигналу:**

-   Gitleaks може побачити секрет у git, але **немає гейта** у CI → збірка не падає
-   Якщо секрет підвантажується з `secret.txt`, не збереженого в git → gitleaks не бачить
-   **Архітектура не має механізму виявлення витоків секретів** - система "мовчить" про проблему

**Виправлення (патерн "Vault CSI для зберігання секретів"):**

-   Секрети тільки через **Vault CSI driver** або External Secrets Operator - це **патерн** безпечної доставки секретів, який створює **сигнал** для перевірки
-   У CI: **gitleaks** (fail build) як **гейт** - це додає **контроль** на рівні пайплайну
-   У кластері: OPA/Kyverno policy перевіряє, що немає `env.value` з секретами - це **контроль** на рівні деплою
-   Для auth: зберігати хеші (bcrypt/argon2), додати rate-limiting
-   **Результат:** секрети не в коді → gitleaks "чисто", Vault CSI → контрольована доставка

---

### Проблема 3 — Healthcheck у Kubernetes є, а в застосунку - немає

**Файл:** `deployment.yaml` + `main.py`  
**Суть:** `livenessProbe` перевіряє `/health`, але такого endpoint у коді не видно → ложно-негативні рестарти або "зелений" деплой без реальної готовності/живучості.  
**Порушений принцип/патерн:** **"Observability as a feature"**, "**Health/Readiness signals**".  
**Чому система "мовчить" без сигналу:**

-   Без узгоджених **health signals** платформа не може відрізнити збій від нормальної роботи
-   Логи відображаються через `print()` → неможливо зібрати події централізовано, SIEM "сліпий"
-   **Архітектура не надає сигналу про стан системи** - система "мовчить" про інциденти

**Виправлення (патерн "Структуроване логування у stdout"):**

-   Додати `/health` (liveness) і `/ready` (readiness), перевіряти залежності (DB/queue) тільки в readiness - це створює **сигнал** для платформи
-   Додати **structured logging** (structlog, OpenTelemetry) у stdout з JSON-структурою -це додає **сигнал** для SIEM/лог-колектора
-   Додати correlation-id для трасування запитів - це додає **сигнал** для аналізу інцидентів
-   Додати мінімальні метрики (Prometheus / OpenTelemetry) як **сигнали** для автоматичного контролю
-   **Результат:** логи агрегуються, SIEM бачить події, можна реагувати на інциденти

---

### Проблема 4 — Kubernetes deployment без securityContext та runtime hardening

**Файл:** `deployment.yaml`  
**Суть:** немає `securityContext` (runAsNonRoot, allowPrivilegeEscalation=false), немає readOnlyRootFilesystem, drop capabilities, seccompProfile, ресурсні requests, imagePullPolicy/immutable tags.  
**Порушений принцип/патерн:** _Defense in Depth_, **_PoLP_**, "Hardened runtime baseline", **"Ізоляція компонентів"**.  
**Чому система "мовчить" без сигналу:**

-   Без **policy gates** у CI/cluster ці поля можна ніколи не додати - і ніхто не помітить, поки не буде інциденту
-   Якщо хтось замінить Helm Chart кастомним YAML з `hostNetwork: true` → **немає сигналу** для перевірки
-   **Архітектура не має механізму автоматичної перевірки відповідності політикам** - система "мовчить" про порушення

**Виправлення (патерн "Policy-as-Code за допомогою OPA"):**

-   Додати `securityContext` на pod/container рівні - це **шаблон** безпечного деплою
-   У CI: **Conftest (OPA)** або kube-linter як **гейт** - це додає **контроль** на рівні пайплайну, перевіряє структуру маніфестів
-   У кластері: Kyverno/Gatekeeper policy як обовʼязковий **контроль** - це додає **сигнал** на рівні кластера, блокує недопустимі зміни
-   **Результат:** будь-яка спроба обійти шаблон → deny, архітектура захищена від змін

---

### Проблема 5 - CI не містить жодних перевірок (немає гейтів)

**Файл:** `ci.yml`  
**Суть:** pipeline лише будує образ. Немає lint/tests, немає SAST, SBOM, scanning secrets, scanning image, IaC/K8s policy checks.  
**Порушений принцип/патерн:** **_Security Gates / Shift-left_**, "**Pipeline as control plane**".  
**Чому система "мовчить" без сигналу:**

-   Без **CI-гейтів** будь-які дефекти (секрети, відкриті SG, root контейнер) проходять у прод
-   Trivy не аналізує залежності, бо не створено SBOM → **немає сигналу** для перевірки
-   tfsec не спрацьовує, бо інфраструктура може бути описана вручну в cloud console → **немає сигналу**
-   **Це ключова проблема контрольованості:** архітектура CI не дозволяє автоматичну перевірку, тому система "мовчить" про всі дефекти до моменту деплою

**Виправлення (патерн "Pipeline as control plane"):**

-   Додати кроки: `ruff`, `mypy`, `pytest`; `semgrep`/`bandit`; `gitleaks`; `syft` (SBOM); `trivy` (container scan); `checkov/tfsec` (Terraform); `kube-linter` (K8s) — кожен крок перевіряє окремий **сигнал**
-   Додати "quality/security **гейт**": збірка падає при High/Critical - це **контроль**, який не дозволяє дефектам пройти далі
-   **Результат:** пайплайн автоматично зупиняє зміни у випадку порушень, перевірка відбувається незалежно від дій розробника

---

### Проблема 6 - Terraform security group відкритий на весь інтернет

**Файл:** `main.tf`  
**Суть:** ingress 443 з `0.0.0.0/0`, немає обмеження джерел, немає VPC/subnet контексту, немає egress-control.  
**Порушений принцип/патерн:** **_PoLP_** (network least privilege), "Zero Trust networking", **"Ізоляція компонентів"** (мережева).  
**Чому система "мовчить" без сигналу:**

-   Без **IaC scanning/policy gate** у CI це легко пропустити
-   Якщо інфраструктура описана вручну в cloud console → tfsec не запускається, бо **немає предмета для перевірки**
-   **Архітектура IaC не надає сигналу про порушення мережевих політик** - система "мовчить" про небезпеку

**Виправлення (патерн "IaC як єдине довірене джерело конфігурацій"):**

-   Параметризувати дозволені CIDR (corporate/VPN), або використовувати ALB + SG-to-SG правила — це **шаблон** мережевої безпеки
-   Додати `tfsec`/`checkov` у CI як **гейт** — це додає **сигнал** про порушення мережевих політик
-   Додати теги/опис/outputs для аудитності — це додає **сигнал** для моніторингу конфігурації
-   **Результат:** повна декларація доступу → tfsec/OPA можуть перевірити, відсутність "ручного втручання" → усе має версії

## 3) Bonus: Виправлені файли

Виправлені версії файлів з реалізацією патернів безпеки розміщені в папці `fix/`:

-   `main.py` — додано типізацію, Pydantic-моделі, health endpoint, секрети з env
-   `ci.yml` — додано гейти: ruff, mypy, pytest, bandit, gitleaks, trivy, syft
-   `deployment.yaml` — додано securityContext, ресурси, probes
-   `main.tf` — параметризовано CIDR блоки
-   `Dockerfile` — додано non-root user, зафіксовані версії
